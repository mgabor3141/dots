#!/usr/bin/env bash
# session-manager — persistent terminal sessions with abduco
#
# Uses abduco for session persistence with pure escape-sequence passthrough
# (no flicker in TUI apps). Sessions are simple numbered IDs; their CWD and
# running process are discovered dynamically from /proc.
#
# Usage:
#   session-manager              Pick/create session for $PWD
#   session-manager [directory]  Pick/create session for given directory
#   session-manager --all        Show all sessions
#   session-manager --hosts      Show sessions across all SSH hosts
#
# Session naming: s:<N>  (sockets in ~/.abduco/)
#
# Detach with Ctrl-\ (abduco default) to return to the session picker.
# Exit the shell normally to end the session and close the terminal.
#
# Environment:
#   ABDUCO_SESSION=1   Set inside managed sessions to prevent nesting

set -Eeuo pipefail
trap 'echo "Error on line $LINENO: $BASH_COMMAND" >&2' ERR

# ── Config ──────────────────────────────────────────────────────────────────

SHELL_CMD="${SHELL:-/bin/sh}"
HOSTNAME="$(hostname 2>/dev/null || echo unknown)"
SSH_TIMEOUT=3
IS_REMOTE=false; [[ -n "${SSH_CONNECTION:-}" ]] && IS_REMOTE=true
VIRGIN_PREFIX="$HOME/.abduco/.virgin-"

shorten() { echo "${1/#$HOME/\~}"; }

sock_for() { echo "$HOME/.abduco/${1}@${HOSTNAME}"; }

# ── Session discovery (via abduco native listing) ───────────────────────────

# Cache abduco output (one call for all queries).
# Format per line: [*| ] <day>\t<date>\t<pid>\t<name>
_ABDUCO_CACHE=""
_ABDUCO_CACHED=false
abduco_cache() {
    $_ABDUCO_CACHED && return
    _ABDUCO_CACHED=true
    _ABDUCO_CACHE="$(abduco 2>&1 || true)"
}

# For an abduco server PID, find the shell child and return:
#   <shell_pid> <child_process_name>
# child_process_name is empty if the shell is idle.
get_shell_info() {
    local abduco_pid="$1"
    local shell_pid child_pid process=""
    shell_pid="$(pgrep -P "$abduco_pid" 2>/dev/null | head -1 || true)"
    [[ -n "$shell_pid" ]] || return 0
    child_pid="$(pgrep -P "$shell_pid" 2>/dev/null | head -1 || true)"
    [[ -n "$child_pid" ]] && process="$(ps -o comm= -p "$child_pid" 2>/dev/null || true)"
    echo "$shell_pid $process"
}

# Get CWD of a process via /proc.
get_cwd() {
    readlink "/proc/$1/cwd" 2>/dev/null || true
}

# Parse abduco listing.  Output: name \t status \t process \t cwd
# Filters to session-manager sessions (name starts with 's:').
parse_sessions() {
    abduco_cache
    echo "$_ABDUCO_CACHE" | while IFS= read -r line; do
        [[ "$line" == Active* ]] && continue
        [[ -z "$line" ]] && continue

        local attached=false
        [[ "${line:0:1}" == "*" ]] && attached=true

        local pid name
        pid="$(awk -F'\t' '{gsub(/^ +/,"",$3); print $3}' <<<"$line")"
        name="$(awk -F'\t' '{print $4}' <<<"$line")"
        [[ "$name" == s:* ]] || continue

        local status="detached"
        $attached && status="attached"

        local shell_info shell_pid="" process="" cwd=""
        shell_info="$(get_shell_info "$pid")"
        if [[ -n "$shell_info" ]]; then
            shell_pid="${shell_info%% *}"
            process="${shell_info#* }"
            cwd="$(get_cwd "$shell_pid")"
        fi

        printf '%s\t%s\t%s\t%s\n' "$name" "$status" "${process:--}" "$cwd"
    done
}

# List sessions matching a directory.  Output: name \t status \t process
list_for_dir() {
    local dir="$1"
    parse_sessions | while IFS=$'\t' read -r name status process cwd; do
        if [[ "$cwd" == "$dir" ]]; then
            printf '%s\t%s\t%s\n' "$name" "$status" "$process"
        fi
    done
}

# List all sessions.  Output: name \t status \t process \t cwd
list_all() {
    parse_sessions
}

# ── SSH host discovery ──────────────────────────────────────────────────────

# Parse ~/.ssh/config for Host entries (skip wildcards, patterns).
list_ssh_hosts() {
    local config="$HOME/.ssh/config"
    [[ -f "$config" ]] || return 0
    awk '/^[Hh]ost[[:space:]]/ {
        for (i = 2; i <= NF; i++) {
            if ($i !~ /[*?!]/) print $i
        }
    }' "$config"
}

# Query a remote host for sessions.  Output: host \t name \t status \t process \t cwd
# Returns nothing if host is unreachable or session-manager not installed.
query_remote_host() {
    local host="$1"
    local output
    output="$(ssh -o ConnectTimeout="$SSH_TIMEOUT" \
                  -o BatchMode=yes \
                  -o StrictHostKeyChecking=accept-new \
                  "$host" \
                  'bash -lc "command -v session-manager >/dev/null 2>&1 && session-manager --list-all-raw"' \
              2>/dev/null)" || return 0
    [[ -z "$output" ]] && return 0
    while IFS=$'\t' read -r name status process cwd; do
        [[ -z "$name" ]] && continue
        printf '%s\t%s\t%s\t%s\t%s\n' "$host" "$name" "$status" "$process" "$cwd"
    done <<<"$output"
}

# Query remote hosts only (excludes local), in parallel.
# Output: host \t name \t status \t process \t cwd
query_remote_hosts() {
    local tmpdir
    tmpdir="$(mktemp -d)"

    local -a hosts=()
    while IFS= read -r host; do
        hosts+=("$host")
        query_remote_host "$host" > "$tmpdir/remote_${host}" &
    done < <(list_ssh_hosts)

    wait

    for host in "${hosts[@]+"${hosts[@]}"}"; do
        cat "$tmpdir/remote_${host}" 2>/dev/null || true
    done

    rm -rf "$tmpdir"
}

# ── Session lifecycle ───────────────────────────────────────────────────────

# Create a detached session, print its name.
# Race-safe: abduco fails if the socket already exists.
create() {
    local dir="$1"
    cd "$dir"

    local n=1
    while (( n <= 100 )); do
        local name="s:${n}"
        if [[ ! -e "$(sock_for "$name")" ]]; then
            if abduco -n "$name" \
                env ABDUCO_SESSION=1 SESSION_NAME="$name" "$SHELL_CMD" 2>/dev/null; then
                touch "${VIRGIN_PREFIX}${name}"
                echo "$name"
                return
            fi
        fi
        (( n++ ))
    done

    echo "session-manager: could not create session after 100 attempts" >&2
    return 1
}

# Attach to a session.  Returns when detached (Ctrl-\) or session ends.
# Sets _ATTACHED_SESSION so the caller can check if it's still alive.
attach() {
    _ATTACHED_SESSION="$1"
    export ABDUCO_SESSION=1
    # abduco enters the alternate screen on attach, which disables
    # terminal scrollback. Undo it with a brief delay after attach.
    (sleep 0.02; printf '\033[?1049l' > /dev/tty 2>/dev/null) &
    abduco -a "$1" 2>/dev/null || true
}

# Returns true if the last attached session is still alive (was detached).
session_alive() {
    [[ -n "${_ATTACHED_SESSION:-}" ]] && [[ -S "$(sock_for "$_ATTACHED_SESSION")" ]]
}

create_and_attach() {
    local name
    name="$(create "$1")"
    local sock
    sock="$(sock_for "$name")"
    local i=0
    while [[ ! -S "$sock" ]] && (( i++ < 20 )); do sleep 0.01; done
    attach "$name"
}

# Remote session lifecycle (over SSH)
remote_attach() {
    local host="${1:-}" name="${2:-}"
    [[ -z "$host" || -z "$name" ]] && return 1
    exec ssh -t "$host" "bash -lc 'abduco -a \"$name\"'"
}

remote_create_and_attach() {
    local host="${1:-}"
    [[ -z "$host" ]] && return 1
    exec ssh -t "$host" 'bash -lc "session-manager --create-and-attach \$HOME"'
}

# ── fzf formatting ──────────────────────────────────────────────────────────

# Indicator logic:
#   green ●  = process running, attached
#   yellow ● = idle (no process), attached
#   green ○  = process running, detached
#   dim ○    = idle, detached

# Output: <name>\t<display>   (name is hidden via --with-nth=2)
# Pool view:  ● pi        or  ○ empty
fmt_pool() {
    local name="$1" status="$2" process="${3:-}"
    [[ "$process" == "-" ]] && process=""
    local dot label
    _dot_for "$status" "$process"
    if [[ -n "$process" ]]; then
        label="$process"
    else
        label="\033[3mempty\033[0m"
    fi
    printf '%s\t%b %b' "$name" "$dot" "$label"
}

# All view:  ● ~/.config/foo › pi   or  ○ ~/.config/foo
fmt_all() {
    local name="$1" status="$2" process="${3:-}" cwd="${4:-}"
    [[ "$process" == "-" ]] && process=""
    local dot label
    _dot_for "$status" "$process"
    label="$(shorten "${cwd:-?}")"
    [[ -n "$process" ]] && label="$label \033[2m›\033[0m $process"
    printf '%s\t%b %b' "$name" "$dot" "$label"
}

# Hosts view:  ● unraid:~/docker › pi   or  ○ unraid:~/docker
fmt_hosts() {
    local host="$1" name="$2" status="$3" process="${4:-}" cwd="${5:-}"
    [[ "$process" == "-" ]] && process=""
    local dot label
    _dot_for "$status" "$process"
    label="\033[1m${host}\033[0m:$(shorten "${cwd:-?}")"
    [[ -n "$process" ]] && label="$label \033[2m›\033[0m $process"
    # Key encodes host and session name for routing
    printf '%s@%s\t%b %b' "$name" "$host" "$dot" "$label"
}

_dot_for() {
    local status="$1" process="$2"
    if [[ "$status" == "attached" ]]; then
        if [[ -n "$process" ]]; then
            dot="\033[32m●\033[0m"
        else
            dot="\033[33m●\033[0m"
        fi
    else
        if [[ -n "$process" ]]; then
            dot="\033[32m○\033[0m"
        else
            dot="\033[2m○\033[0m"
        fi
    fi
}

# Extract the session name from fzf output (first tab-delimited field)
extract_name() {
    local input="${1:-}"
    [[ -z "$input" ]] && return 0
    awk -F'\t' '{print $1}' <<<"$input"
}

# ── Kill helpers ────────────────────────────────────────────────────────────

kill_session() {
    local name="${1:-}"
    [[ -z "$name" ]] && return 0
    local sock
    sock="$(sock_for "$name")"
    [[ -S "$sock" ]] && rm -f "$sock"
}

# Kill session socket + abduco server process.
kill_session_full() {
    local name="${1:-}"
    [[ -z "$name" ]] && return 0
    kill_session "$name"
    abduco_cache
    local pid
    pid="$(echo "$_ABDUCO_CACHE" | awk -F'\t' -v n="$name" '$4 == n {gsub(/^ +/,"",$3); print $3}')"
    if [[ -n "$pid" ]]; then
        kill "$pid" 2>/dev/null || true
    fi
    rm -f "${VIRGIN_PREFIX}${name}"
}

# Kill a session on any host.  Key format: <name>@<host>
kill_session_any() {
    local key="${1:-}"
    [[ -z "$key" ]] && return 0
    local name="${key%%@*}"
    local host="${key##*@}"
    if [[ "$host" == "$HOSTNAME" ]]; then
        kill_session "$name"
    else
        ssh -o ConnectTimeout="$SSH_TIMEOUT" -o BatchMode=yes \
            "$host" "bash -lc \"session-manager --kill-session '$name'\"" 2>/dev/null || true
    fi
}

# ── Cleanup ─────────────────────────────────────────────────────────────────

# Clean up detached sessions that were never interacted with (virgin).
cleanup_virgin() {
    _ABDUCO_CACHED=false
    while IFS=$'\t' read -r name status _process _cwd; do
        if [[ "$status" == "detached" && -f "${VIRGIN_PREFIX}${name}" ]]; then
            kill_session_full "$name"
        fi
    done < <(parse_sessions)
}

# Clean up all detached+idle sessions in a directory.
cleanup_idle_dir() {
    local dir="$1"
    _ABDUCO_CACHED=false
    while IFS=$'\t' read -r name status process; do
        if [[ "$status" == "detached" && ( "$process" == "-" || -z "$process" ) ]]; then
            kill_session_full "$name"
        fi
    done < <(list_for_dir "$dir")
}

# Clean up all detached+idle local sessions.
cleanup_idle_all() {
    _ABDUCO_CACHED=false
    while IFS=$'\t' read -r name status process _cwd; do
        if [[ "$status" == "detached" && ( "$process" == "-" || -z "$process" ) ]]; then
            kill_session_full "$name"
        fi
    done < <(parse_sessions)
}

# ── List commands for fzf reload ────────────────────────────────────────────

list_dir_fmt() {
    local dir="$1"
    _ABDUCO_CACHED=false
    printf '\t  + new session\n'
    local -a active=() idle=()
    while IFS=$'\t' read -r name status process; do
        [[ -z "$name" ]] && continue
        local line
        line="$(fmt_pool "$name" "$status" "$process")"
        if [[ "$status" == "detached" && ( "$process" == "-" || -z "$process" ) ]]; then
            idle+=("$line")
        else
            active+=("$line")
        fi
    done < <(list_for_dir "$dir")
    (( ${#active[@]} > 0 )) && printf '%b\n' "${active[@]}"
    (( ${#idle[@]} > 0 )) && printf '%b\n' "${idle[@]}"
}

list_all_fmt() {
    _ABDUCO_CACHED=false
    printf '\t  + new session in ~\n'
    local -a active=() idle=()
    while IFS=$'\t' read -r name status process cwd; do
        [[ -z "$name" ]] && continue
        local line
        line="$(fmt_all "$name" "$status" "$process" "$cwd")"
        if [[ "$status" == "detached" && ( "$process" == "-" || -z "$process" ) ]]; then
            idle+=("$line")
        else
            active+=("$line")
        fi
    done < <(list_all)
    (( ${#active[@]} > 0 )) && printf '%b\n' "${active[@]}"
    (( ${#idle[@]} > 0 )) && printf '%b\n' "${idle[@]}"
}

list_hosts_fmt() {
    _ABDUCO_CACHED=false
    local found=false
    # "New session" entries: one per remote host
    while IFS= read -r host; do
        printf '\t  + new session on %s\n' "$host"
        found=true
    done < <(list_ssh_hosts)
    # Sessions from remote hosts
    while IFS=$'\t' read -r host name status process cwd; do
        [[ -z "$host" ]] && continue
        printf '%b\n' "$(fmt_hosts "$host" "$name" "$status" "$process" "$cwd")"
        found=true
    done < <(query_remote_hosts)
    $found || printf '\t  \033[2mno remote hosts configured in ~/.ssh/config\033[0m\n'
}

# ── Pickers ─────────────────────────────────────────────────────────────────

pick_for_dir() {
    local dir="$1"
    local fast="${2:-false}"
    local -a entries=()
    local -a detached_names=()

    while IFS=$'\t' read -r name status process; do
        [[ -z "$name" ]] && continue
        entries+=("$(fmt_pool "$name" "$status" "$process")")
        [[ "$status" == "detached" ]] && detached_names+=("$name")
    done < <(list_for_dir "$dir")

    if $fast; then
        # No sessions or all attached — create directly (unless home with detached elsewhere)
        if (( ${#entries[@]} == 0 || ${#detached_names[@]} == 0 )); then
            # In home dir, check for detached sessions in other directories first
            if [[ "$dir" == "$HOME" ]]; then
                local has_detached_elsewhere=false
                while IFS=$'\t' read -r _n status _p cwd; do
                    if [[ "$status" == "detached" && "$cwd" != "$HOME" ]]; then
                        has_detached_elsewhere=true; break
                    fi
                done < <(parse_sessions)
                if $has_detached_elsewhere; then
                    pick_all "$dir"; return
                fi
            fi
            create_and_attach "$dir"; return
        fi

        # Single detached session — reattach directly
        if (( ${#detached_names[@]} == 1 )); then
            attach "${detached_names[0]}"; return
        fi
    fi

    local self="$0"
    local header
    header="$(printf '\033[1;34m%s\033[0m  \033[2mctrl-a › all\033[0m\n' "Sessions in $(shorten "$dir")"
             printf '\033[36menter\033[0m attach  \033[36mctrl-n\033[0m new  \033[36mctrl-r\033[0m raw\n'
             printf '\033[33mctrl-x\033[0m kill  \033[33mctrl-d\033[0m clean idle')"
    local chosen

    chosen="$({
        printf '\t  + new session\n'
        if (( ${#entries[@]} > 0 )); then
            printf '%b\n' "${entries[@]}"
        fi
    } | fzf --ansi --header="$header" \
          --delimiter='\t' --with-nth=2 \
          --expect=ctrl-n,ctrl-a,ctrl-r \
          --no-sort --reverse --height=16 \
          --bind "ctrl-x:execute-silent($self --kill-session {1})+reload-sync($self --list-dir-fmt $(printf '%q' "$dir"))+transform(echo pos\(\$FZF_POS\))" \
          --bind "ctrl-d:execute-silent($self --cleanup-idle-dir $(printf '%q' "$dir"))+reload-sync($self --list-dir-fmt $(printf '%q' "$dir"))")" || true

    [[ -z "$chosen" ]] && return

    local key line
    key="$(head -1 <<<"$chosen")"
    line="$(sed -n '2p' <<<"$chosen")"

    case "$key" in
        ctrl-a) pick_all "$dir"; return ;;
        ctrl-n) create_and_attach "$dir"; return ;;
        ctrl-r) exec env TMS_SKIP=1 "$SHELL_CMD"; return ;;
    esac

    if [[ "$line" == *"new session"* ]]; then
        create_and_attach "$dir"
    elif [[ -n "$line" ]]; then
        attach "$(extract_name "$line")"
    fi
}

pick_all() {
    local dir="${1:-}"
    local -a entries=()

    while IFS=$'\t' read -r name status process cwd; do
        [[ -z "$name" ]] && continue
        entries+=("$(fmt_all "$name" "$status" "$process" "$cwd")")
    done < <(list_all)

    local self="$0"
    local next_label="hosts"
    $IS_REMOTE && next_label="directory"
    local header
    header="$(printf '\033[1;32mAll sessions\033[0m  \033[2mctrl-a › %s\033[0m\n' "$next_label"
             printf '\033[36menter\033[0m attach  \033[36mctrl-n\033[0m new  \033[36mctrl-r\033[0m raw\n'
             printf '\033[33mctrl-x\033[0m kill  \033[33mctrl-d\033[0m clean idle')"
    local chosen

    chosen="$({
        printf '\t  + new session in ~\n'
        if (( ${#entries[@]} > 0 )); then
            printf '%b\n' "${entries[@]}"
        fi
    } | fzf --ansi --header="$header" \
              --delimiter='\t' --with-nth=2 \
              --expect=ctrl-a,ctrl-n,ctrl-r \
              --no-sort --reverse --height=16 \
              --bind "ctrl-x:execute-silent($self --kill-session {1})+reload-sync($self --list-all-fmt)+transform(echo pos\(\$FZF_POS\))" \
              --bind "ctrl-d:execute-silent($self --cleanup-idle-all)+reload-sync($self --list-all-fmt)")" || true

    [[ -z "$chosen" ]] && return

    local key line
    key="$(head -1 <<<"$chosen")"
    line="$(sed -n '2p' <<<"$chosen")"

    case "$key" in
        ctrl-a)
            if $IS_REMOTE || [[ -z "$dir" ]]; then
                pick_for_dir "${dir:-$PWD}"
            else
                pick_hosts "$dir"
            fi
            return ;;
        ctrl-n) create_and_attach "$HOME"; return ;;
        ctrl-r) exec env TMS_SKIP=1 "$SHELL_CMD"; return ;;
    esac

    if [[ "$line" == *"new session"* ]]; then
        create_and_attach "$HOME"
    elif [[ -n "$line" ]]; then
        attach "$(extract_name "$line")"
    fi
}

pick_hosts() {
    local dir="${1:-}"

    local -a ssh_hosts=()
    local has_hosts=false
    while IFS= read -r host; do
        ssh_hosts+=("$host")
        has_hosts=true
    done < <(list_ssh_hosts)

    local self="$0"
    local header
    header="$(printf '\033[1;35mRemote hosts\033[0m  \033[2mctrl-a › local\033[0m\n'
             printf '\033[36menter\033[0m attach\n'
             printf '\033[33mctrl-x\033[0m kill')"
    local chosen

    # Show picker immediately with "new session" entries + loading indicator,
    # then reload with full data once SSH queries complete.
    chosen="$({
        for host in "${ssh_hosts[@]+"${ssh_hosts[@]}"}"; do
            printf '\t  + new session on %s\n' "$host"
        done
        $has_hosts || printf '\t  \033[2mno remote hosts configured in ~/.ssh/config\033[0m\n'
    } | fzf --ansi --header="$header" \
              --delimiter='\t' --with-nth=2 \
              --expect=ctrl-a \
              --no-sort --reverse --height=16 \
              --bind "load:reload($self --list-hosts-fmt)+unbind(load)" \
              --bind "ctrl-x:execute-silent($self --kill-session-any {1})+reload-sync($self --list-hosts-fmt)+transform(echo pos\(\$FZF_POS\))")" || true

    [[ -z "$chosen" ]] && return

    local key line
    key="$(head -1 <<<"$chosen")"
    line="$(sed -n '2p' <<<"$chosen")"

    case "$key" in
        ctrl-a)
            if [[ -n "$dir" ]]; then
                pick_for_dir "$dir"
            else
                pick_all
            fi
            return ;;
    esac

    if [[ "$line" == *"new session on "* ]]; then
        local target_host="${line##*new session on }"
        remote_create_and_attach "$target_host"
    elif [[ -n "$line" ]]; then
        local session_key
        session_key="$(extract_name "$line")"
        local sname="${session_key%%@*}"
        local shost="${session_key##*@}"
        remote_attach "$shost" "$sname"
    fi
}

# ── SSH agent ───────────────────────────────────────────────────────────────

fixup_ssh_agent() {
    if [[ -n "${SSH_AUTH_SOCK:-}" && "$SSH_AUTH_SOCK" != "$HOME/.ssh/agent.sock" ]]; then
        ln -sf "$SSH_AUTH_SOCK" "$HOME/.ssh/agent.sock" 2>/dev/null || true
    fi
}

# ── Main ────────────────────────────────────────────────────────────────────

main() {
    local mode="dir"
    local dir="$PWD"
    local first=true

    while (( $# )); do
        case "$1" in
            -a|--all)    mode="all";   shift ;;
            -H|--hosts)  mode="hosts"; shift ;;
            -h|--help)
                cat <<-'EOF'
				Usage: session-manager [options] [directory]

				  session-manager              Pick/create session for $PWD
				  session-manager <dir>        Pick/create session for <dir>
				  session-manager --all        Show all sessions

				Inside a session, press Ctrl-\ to detach and return to the picker.
				EOF
                exit 0 ;;
            # Internal commands (used by fzf --bind and remote SSH)
            --kill-session)       [[ -n "${2:-}" ]] && kill_session "$2"; exit ;;
            --kill-session-any)   [[ -n "${2:-}" ]] && kill_session_any "$2"; exit ;;
            --list-dir-fmt)       list_dir_fmt "${2:-$PWD}"; exit ;;
            --list-all-fmt)       list_all_fmt; exit ;;
            --list-all-raw)       _ABDUCO_CACHED=false; parse_sessions; exit ;;
            --list-hosts-fmt)     list_hosts_fmt; exit ;;
            --cleanup-idle-dir)   [[ -n "${2:-}" ]] && cleanup_idle_dir "$2"; exit ;;
            --cleanup-idle-all)   cleanup_idle_all; exit ;;
            --create-and-attach)  create_and_attach "${2:-$HOME}"; exit ;;
            *) dir="$(cd "$1" && pwd)"; shift ;;
        esac
    done

    fixup_ssh_agent

    while true; do
        _ABDUCO_CACHED=false
        cleanup_virgin
        _ABDUCO_CACHED=false

        case "$mode" in
            dir)   pick_for_dir "$dir" "$first" ;;
            all)   pick_all ;;
            hosts)
                if $IS_REMOTE; then
                    echo "session-manager: hosts view disabled over SSH" >&2
                    exit 1
                fi
                pick_hosts ;;
        esac

        # After attach() returns (or picker was dismissed):
        # - Session still alive → user detached (Ctrl-\) → show picker again
        # - Session dead → user exited shell → close terminal
        # - No session attached (picker dismissed) → exit
        if session_alive; then
            # Detached — show the all-sessions picker next
            mode="all"
            first=false
            continue
        fi
        break
    done
}

main "$@"
