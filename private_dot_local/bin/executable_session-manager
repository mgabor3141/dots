#!/usr/bin/env bash
# session-manager — persistent terminal sessions with abduco
#
# Uses abduco for session persistence with pure escape-sequence passthrough
# (no flicker in TUI apps). Sessions are simple numbered IDs; their CWD and
# running process are discovered dynamically from /proc.
#
# Usage:
#   session-manager              Pick/create session for $PWD
#   session-manager [directory]  Pick/create session for given directory
#   session-manager --all        Show all sessions
#
# Session naming: s:<N>  (sockets in ~/.abduco/)
#
# Environment:
#   ABDUCO_SESSION=1   Set inside managed sessions to prevent nesting

set -Eeuo pipefail
trap 'echo "Error on line $LINENO: $BASH_COMMAND" >&2' ERR

# ── Config ──────────────────────────────────────────────────────────────────

SHELL_CMD="${SHELL:-/bin/sh}"
HOSTNAME="$(hostname 2>/dev/null || echo unknown)"

shorten() { echo "${1/#$HOME/\~}"; }

# ── Session discovery (via abduco native listing) ───────────────────────────

# Cache abduco output (one call for all queries).
# Format per line: [*| ] <day>\t<date>\t<pid>\t<name>
_ABDUCO_CACHE=""
_ABDUCO_CACHED=false
abduco_cache() {
    $_ABDUCO_CACHED && return
    _ABDUCO_CACHED=true
    _ABDUCO_CACHE="$(abduco 2>&1 || true)"
}

# For an abduco server PID, find the shell child and return:
#   <shell_pid> <child_process_name>
# child_process_name is empty if the shell is idle.
get_shell_info() {
    local abduco_pid="$1"
    local shell_pid child_pid process=""
    shell_pid="$(pgrep -P "$abduco_pid" 2>/dev/null | head -1 || true)"
    [[ -n "$shell_pid" ]] || return 0
    child_pid="$(pgrep -P "$shell_pid" 2>/dev/null | head -1 || true)"
    [[ -n "$child_pid" ]] && process="$(ps -o comm= -p "$child_pid" 2>/dev/null || true)"
    echo "$shell_pid $process"
}

# Get CWD of a process via /proc.
get_cwd() {
    readlink "/proc/$1/cwd" 2>/dev/null || true
}

# Parse abduco listing.  Output: name \t status \t process \t cwd
# Filters to session-manager sessions (name starts with 's:').
parse_sessions() {
    abduco_cache
    echo "$_ABDUCO_CACHE" | while IFS= read -r line; do
        [[ "$line" == Active* ]] && continue
        [[ -z "$line" ]] && continue

        local attached=false
        [[ "${line:0:1}" == "*" ]] && attached=true

        local pid name
        pid="$(awk -F'\t' '{gsub(/^ +/,"",$3); print $3}' <<<"$line")"
        name="$(awk -F'\t' '{print $4}' <<<"$line")"
        [[ "$name" == s:* ]] || continue

        local status="detached"
        $attached && status="attached"

        local shell_info shell_pid="" process="" cwd=""
        shell_info="$(get_shell_info "$pid")"
        if [[ -n "$shell_info" ]]; then
            shell_pid="${shell_info%% *}"
            process="${shell_info#* }"
            cwd="$(get_cwd "$shell_pid")"
        fi

        printf '%s\t%s\t%s\t%s\n' "$name" "$status" "${process:--}" "$cwd"
    done
}

# List sessions matching a directory.  Output: name \t status \t process
list_for_dir() {
    local dir="$1"
    parse_sessions | while IFS=$'\t' read -r name status process cwd; do
        if [[ "$cwd" == "$dir" ]]; then
            printf '%s\t%s\t%s\n' "$name" "$status" "$process"
        fi
    done
}


# List all sessions.  Output: name \t status \t process \t cwd
list_all() {
    parse_sessions
}

# ── Session lifecycle ───────────────────────────────────────────────────────

# Create a detached session, print its name.
# Race-safe: abduco fails if the socket already exists.
create() {
    local dir="$1"
    cd "$dir"

    local n=1
    while (( n <= 100 )); do
        local name="s:${n}"
        if [[ ! -e "$HOME/.abduco/${name}@${HOSTNAME}" ]]; then
            if abduco -n "$name" \
                env ABDUCO_SESSION=1 SESSION_NAME="$name" "$SHELL_CMD" 2>/dev/null; then
                echo "$name"
                return
            fi
        fi
        (( n++ ))
    done

    echo "session-manager: could not create session after 100 attempts" >&2
    return 1
}

attach() {
    export ABDUCO_SESSION=1
    # abduco enters the alternate screen on attach, which disables
    # terminal scrollback. Undo it with a brief delay after attach.
    (sleep 0.02; printf '\033[?1049l' > /dev/tty) &
    exec abduco -a "$1"
}

create_and_attach() {
    local name
    name="$(create "$1")"
    local sock="$HOME/.abduco/${name}@${HOSTNAME}"
    local i=0
    while [[ ! -S "$sock" ]] && (( i++ < 20 )); do sleep 0.01; done
    attach "$name"
}

# ── fzf formatting ──────────────────────────────────────────────────────────

# Indicator logic:
#   green ●  = process running, attached
#   yellow ● = idle (no process), attached
#   green ○  = process running, detached
#   dim ○    = idle, detached
#
# Display (pool view):  ● s:1 (pi)
# Display (all view):   ● s:1 (pi)  [~/projects/foo]
#                        ○ s:2       [~]
# Output: <name>\t<display>   (name is hidden via --with-nth=2)
# Pool view:  ● pi        or  ○ empty
fmt_pool() {
    local name="$1" status="$2" process="${3:-}"
    [[ "$process" == "-" ]] && process=""
    local dot label
    _dot_for "$status" "$process"
    if [[ -n "$process" ]]; then
        label="$process"
    else
        label="\033[3mempty\033[0m"
    fi
    printf '%s\t%b %b' "$name" "$dot" "$label"
}

# All view:  ● ~/.config/foo › pi   or  ○ ~/.config/foo
fmt_all() {
    local name="$1" status="$2" process="${3:-}" cwd="${4:-}"
    [[ "$process" == "-" ]] && process=""
    local dot label
    _dot_for "$status" "$process"
    label="$(shorten "${cwd:-?}")"
    [[ -n "$process" ]] && label="$label \033[2m›\033[0m $process"
    printf '%s\t%b %b' "$name" "$dot" "$label"
}

_dot_for() {
    local status="$1" process="$2"
    if [[ "$status" == "attached" ]]; then
        if [[ -n "$process" ]]; then
            dot="\033[32m●\033[0m"
        else
            dot="\033[33m●\033[0m"
        fi
    else
        if [[ -n "$process" ]]; then
            dot="\033[32m○\033[0m"
        else
            dot="\033[2m○\033[0m"
        fi
    fi
}

# Extract the session name from fzf output (first tab-delimited field)
extract_name() {
    awk -F'\t' '{print $1}' <<<"$1"
}

# ── Kill helper (callable from fzf --bind) ──────────────────────────────────

kill_session() {
    local name="$1"
    local sock="$HOME/.abduco/${name}@${HOSTNAME}"
    [[ -S "$sock" ]] && rm -f "$sock"
}

# ── List commands for fzf reload ────────────────────────────────────────────

list_dir_fmt() {
    local dir="$1"
    _ABDUCO_CACHED=false
    printf '\t  + new session\n'
    while IFS=$'\t' read -r name status process; do
        [[ -z "$name" ]] && continue
        printf '%b\n' "$(fmt_pool "$name" "$status" "$process")"
    done < <(list_for_dir "$dir")
}

list_all_fmt() {
    _ABDUCO_CACHED=false
    while IFS=$'\t' read -r name status process cwd; do
        [[ -z "$name" ]] && continue
        printf '%b\n' "$(fmt_all "$name" "$status" "$process" "$cwd")"
    done < <(list_all)
}

# ── Pickers ─────────────────────────────────────────────────────────────────

pick_for_dir() {
    local dir="$1"
    local -a entries=()
    local -a detached_names=()

    while IFS=$'\t' read -r name status process; do
        [[ -z "$name" ]] && continue
        entries+=("$(fmt_pool "$name" "$status" "$process")")
        [[ "$status" == "detached" ]] && detached_names+=("$name")
    done < <(list_for_dir "$dir")

    # No sessions for this dir — create one directly
    if (( ${#entries[@]} == 0 )); then
        create_and_attach "$dir"; return
    fi

    # Single detached session — reattach directly
    if (( ${#entries[@]} == 1 && ${#detached_names[@]} == 1 )); then
        attach "${detached_names[0]}"; return
    fi

    local self="$0"
    local header="Sessions in $(shorten "$dir") │ enter: attach │ ctrl-n: new │ ctrl-r: raw │ ctrl-a: all │ ctrl-x: kill"
    local chosen

    chosen="$({
        printf '\t  + new session\n'
        printf '%b\n' "${entries[@]}"
    } | fzf --ansi --header="$header" \
          --delimiter='\t' --with-nth=2 \
          --expect=ctrl-n,ctrl-a,ctrl-r \
          --no-sort --reverse --height=~50% \
          --bind "ctrl-x:execute-silent($self --kill-session {1})+reload-sync($self --list-dir-fmt $(printf '%q' "$dir"))+transform(echo pos\(\$FZF_POS\))")" || true

    local key line
    key="$(head -1 <<<"$chosen")"
    line="$(tail -1 <<<"$chosen")"

    case "$key" in
        ctrl-a) pick_all "$dir"; return ;;
        ctrl-n) create_and_attach "$dir"; return ;;
        ctrl-r) exec env TMS_SKIP=1 "$SHELL_CMD"; return ;;
    esac

    if [[ "$line" == *"new session"* ]]; then
        create_and_attach "$dir"
    elif [[ -n "$line" ]]; then
        attach "$(extract_name "$line")"
    fi
}

pick_all() {
    local dir="${1:-}"
    local -a entries=()

    while IFS=$'\t' read -r name status process cwd; do
        [[ -z "$name" ]] && continue
        entries+=("$(fmt_all "$name" "$status" "$process" "$cwd")")
    done < <(list_all)

    if (( ${#entries[@]} == 0 )); then
        echo "No sessions found."; return 1
    fi

    local self="$0"
    local header="All sessions │ enter: attach │ ctrl-a: directory │ ctrl-x: kill"
    local expect_keys="ctrl-x"
    [[ -n "$dir" ]] && expect_keys="ctrl-a"
    local chosen

    chosen="$({
        printf '\t  + new session in ~\n'
        printf '%b\n' "${entries[@]}"
    } | fzf --ansi --header="$header" \
              --delimiter='\t' --with-nth=2 \
              --expect=$expect_keys \
              --no-sort --reverse --height=~50% \
              --bind "ctrl-x:execute-silent($self --kill-session {1})+reload-sync($self --list-all-fmt)+transform(echo pos\(\$FZF_POS\))")" || true

    local key line
    key="$(head -1 <<<"$chosen")"
    line="$(tail -1 <<<"$chosen")"

    case "$key" in
        ctrl-a) pick_for_dir "$dir"; return ;;
    esac

    if [[ "$line" == *"new session"* ]]; then
        create_and_attach "$HOME"
    elif [[ -n "$line" ]]; then
        attach "$(extract_name "$line")"
    fi
}

# ── SSH agent ───────────────────────────────────────────────────────────────

fixup_ssh_agent() {
    if [[ -n "${SSH_AUTH_SOCK:-}" && "$SSH_AUTH_SOCK" != "$HOME/.ssh/agent.sock" ]]; then
        ln -sf "$SSH_AUTH_SOCK" "$HOME/.ssh/agent.sock" 2>/dev/null || true
    fi
}

# ── Main ────────────────────────────────────────────────────────────────────

main() {
    local mode="dir"
    local dir="$PWD"

    while (( $# )); do
        case "$1" in
            -a|--all)  mode="all";  shift ;;
            -h|--help)
                cat <<-'EOF'
				Usage: session-manager [options] [directory]

				  session-manager              Pick/create session for $PWD
				  session-manager <dir>        Pick/create session for <dir>
				  session-manager --all        Show all sessions
				EOF
                exit 0 ;;
            # Internal commands used by fzf --bind
            --kill-session)     kill_session "$2"; exit ;;
            --list-dir-fmt)     list_dir_fmt "$2"; exit ;;
            --list-all-fmt)     list_all_fmt; exit ;;
            *) dir="$(cd "$1" && pwd)"; shift ;;
        esac
    done

    fixup_ssh_agent

    case "$mode" in
        dir) pick_for_dir "$dir" ;;
        all) pick_all ;;
    esac
}

main "$@"
