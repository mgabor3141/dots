#!/usr/bin/env bash
# tms - tmux session manager
# Manages tmux sessions pooled by working directory.
#
# Usage:
#   tms              Attach to / create session for $PWD
#   tms --all        Show picker for all sessions across all pools
#   tms --kill       Kill sessions (picker)
#   tms --help       Show help
#
# Session naming: <dir-basename>/<N> (e.g. dotfiles/1, pi/2)
# Full pwd stored in tmux env var TMS_PWD on each session.

set -Eeuo pipefail
trap 'echo "Error on line $LINENO: $BASH_COMMAND" >&2' ERR

# --- Helpers ---

get_pool_dir() {
    echo "${1:-$PWD}"
}

# Get sessions for a given directory (by matching TMS_PWD env var)
# Output: session_name\tattached\tcommand
get_pool_sessions() {
    local pool_dir="$1"
    while IFS= read -r sess; do
        local name attached
        name="$(echo "$sess" | cut -d: -f1)"
        attached="$(echo "$sess" | cut -d: -f2)"
        # Check if this session's TMS_PWD matches
        local sess_pwd
        sess_pwd="$(tmux show-environment -t "$name" TMS_PWD 2>/dev/null | sed 's/^TMS_PWD=//' || true)"
        if [[ "$sess_pwd" == "$pool_dir" ]]; then
            local pane_cmd
            pane_cmd="$(tmux list-panes -t "$name" -F '#{pane_current_command}' 2>/dev/null | head -1 || echo "?")"
            local pane_path
            pane_path="$(tmux list-panes -t "$name" -F '#{pane_current_path}' 2>/dev/null | head -1 || echo "")"
            local status_str
            if [[ "$attached" -gt 0 ]]; then
                status_str="attached"
            else
                status_str="detached"
            fi
            printf '%s\t%s\t%s\t%s\n' "$name" "$status_str" "$pane_cmd" "$pane_path"
        fi
    done < <(tmux list-sessions -F '#{session_name}:#{session_attached}' 2>/dev/null || true)
}

# Get ALL tms-managed sessions (those with TMS_PWD set)
get_all_sessions() {
    while IFS= read -r sess; do
        local name attached
        name="$(echo "$sess" | cut -d: -f1)"
        attached="$(echo "$sess" | cut -d: -f2)"
        local sess_pwd
        sess_pwd="$(tmux show-environment -t "$name" TMS_PWD 2>/dev/null | sed 's/^TMS_PWD=//' || true)"
        if [[ -n "$sess_pwd" ]]; then
            local pane_cmd
            pane_cmd="$(tmux list-panes -t "$name" -F '#{pane_current_command}' 2>/dev/null | head -1 || echo "?")"
            local pane_path
            pane_path="$(tmux list-panes -t "$name" -F '#{pane_current_path}' 2>/dev/null | head -1 || echo "")"
            local status_str
            if [[ "$attached" -gt 0 ]]; then
                status_str="attached"
            else
                status_str="detached"
            fi
            printf '%s\t%s\t%s\t%s\t%s\n' "$name" "$status_str" "$pane_cmd" "$pane_path" "$sess_pwd"
        fi
    done < <(tmux list-sessions -F '#{session_name}:#{session_attached}' 2>/dev/null || true)
}

# Sanitize directory name for use in tmux session name
sanitize_name() {
    local dir="$1"
    # Use basename, replace dots/spaces with dashes
    local base
    base="$(basename "$dir")"
    # Home dir special case
    if [[ "$dir" == "$HOME" ]]; then
        base="home"
    fi
    echo "$base" | tr ' ./' '---'
}

# Create a new session for a pool directory.
# Race-safe: if tmux new-session fails (duplicate name), retry next number.
create_session() {
    local pool_dir="$1"
    local base
    base="$(sanitize_name "$pool_dir")"

    local n=1
    local session_name
    while true; do
        session_name="${base}/${n}"
        if tmux new-session -d -s "$session_name" -c "$pool_dir" 2>/dev/null; then
            tmux set-environment -t "$session_name" TMS_PWD "$pool_dir"
            echo "$session_name"
            return
        fi
        ((n++))
        # Safety valve
        if [[ $n -gt 100 ]]; then
            echo "tms: failed to create session after 100 attempts" >&2
            return 1
        fi
    done
}

# Format session line for fzf display
format_session_line() {
    local name="$1" status="$2" cmd="$3" path="$4" pool="${5:-}"
    local color_status
    if [[ "$status" == "attached" ]]; then
        color_status="\033[33m●\033[0m"  # yellow dot
    else
        color_status="\033[32m●\033[0m"  # green dot
    fi
    if [[ -n "$pool" ]]; then
        printf "${color_status} %-20s  %-12s  %s  [%s]" "$name" "$cmd" "$path" "$pool"
    else
        printf "${color_status} %-20s  %-12s  %s" "$name" "$cmd" "$path"
    fi
}

# --- Picker ---

pick_session_for_pool() {
    local pool_dir="$1"
    local entries=()
    local unattached_sessions=()

    while IFS=$'\t' read -r name status cmd path; do
        [[ -z "$name" ]] && continue
        entries+=("$(format_session_line "$name" "$status" "$cmd" "$path")")
        if [[ "$status" == "detached" ]]; then
            unattached_sessions+=("$name")
        fi
    done < <(get_pool_sessions "$pool_dir")

    # Fast paths
    if [[ ${#entries[@]} -eq 0 ]]; then
        # No sessions — create one directly
        create_and_attach "$pool_dir"
        return
    fi

    if [[ ${#unattached_sessions[@]} -eq 1 && ${#entries[@]} -eq 1 ]]; then
        # Exactly one session, unattached — attach directly
        exec tmux attach-session -t "=${unattached_sessions[0]}"
    fi

    # Show picker
    local header
    header="Sessions for $(shorten_path "$pool_dir") │ enter: attach │ ctrl-n: new │ ctrl-a: all pools │ ctrl-x: kill"

    local new_entry="  + new session"
    local selection
    selection="$(
        {
            echo "$new_entry"
            printf '%b\n' "${entries[@]}"
        } | fzf --ansi --header="$header" \
              --bind="ctrl-n:execute-silent(echo NEW)+accept" \
              --bind="ctrl-a:execute-silent(echo ALL)+abort" \
              --bind="ctrl-x:execute-silent(echo KILL)+abort" \
              --expect=ctrl-n,ctrl-a,ctrl-x \
              --no-sort --reverse --height=~50%
    )" || true

    # Parse fzf output (first line = key pressed, second line = selected item)
    local key selected
    key="$(echo "$selection" | head -1)"
    selected="$(echo "$selection" | tail -1)"

    case "$key" in
        ctrl-a)
            pick_session_all
            return
            ;;
        ctrl-x)
            kill_sessions
            return
            ;;
        ctrl-n)
            create_and_attach "$pool_dir"
            return
            ;;
    esac

    if [[ "$selected" == "$new_entry" ]]; then
        create_and_attach "$pool_dir"
    elif [[ -n "$selected" ]]; then
        # Extract session name (after the dot, first field)
        local sess_name
        sess_name="$(echo "$selected" | sed 's/^[^ ]* //' | awk '{print $1}')"
        exec tmux attach-session -t "=${sess_name}"
    fi
}

pick_session_all() {
    local entries=()

    while IFS=$'\t' read -r name status cmd path pool; do
        [[ -z "$name" ]] && continue
        local short_pool
        short_pool="$(shorten_path "$pool")"
        entries+=("$(format_session_line "$name" "$status" "$cmd" "$path" "$short_pool")")
    done < <(get_all_sessions)

    if [[ ${#entries[@]} -eq 0 ]]; then
        echo "No tms sessions found."
        return 1
    fi

    local header="All sessions │ enter: attach │ ctrl-x: kill"

    local selection
    selection="$(
        printf '%b\n' "${entries[@]}" | fzf --ansi --header="$header" \
              --bind="ctrl-x:execute-silent(echo KILL)+abort" \
              --expect=ctrl-x \
              --no-sort --reverse --height=~50%
    )" || true

    local key selected
    key="$(echo "$selection" | head -1)"
    selected="$(echo "$selection" | tail -1)"

    case "$key" in
        ctrl-x)
            kill_sessions
            return
            ;;
    esac

    if [[ -n "$selected" ]]; then
        local sess_name
        sess_name="$(echo "$selected" | sed 's/^[^ ]* //' | awk '{print $1}')"
        exec tmux attach-session -t "=${sess_name}"
    fi
}

kill_sessions() {
    local entries=()

    while IFS=$'\t' read -r name status cmd path pool; do
        [[ -z "$name" ]] && continue
        local short_pool
        short_pool="$(shorten_path "$pool")"
        entries+=("$(format_session_line "$name" "$status" "$cmd" "$path" "$short_pool")")
    done < <(get_all_sessions)

    if [[ ${#entries[@]} -eq 0 ]]; then
        echo "No tms sessions to kill."
        return
    fi

    local header="Kill sessions (tab to multi-select) │ enter: kill selected"

    local selection
    selection="$(
        printf '%b\n' "${entries[@]}" | fzf --ansi --header="$header" \
              --multi --no-sort --reverse --height=~50%
    )" || true

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local sess_name
        sess_name="$(echo "$line" | sed 's/^[^ ]* //' | awk '{print $1}')"
        tmux kill-session -t "=${sess_name}" 2>/dev/null && echo "Killed: $sess_name"
    done <<< "$selection"
}

create_and_attach() {
    local pool_dir="$1"
    local sess_name
    sess_name="$(create_session "$pool_dir")"
    exec tmux attach-session -t "=${sess_name}"
}

shorten_path() {
    local p="$1"
    echo "${p/#$HOME/~}"
}

# --- SSH agent fixup ---
fixup_ssh_agent() {
    # Update SSH_AUTH_SOCK in tmux global env so reattached sessions get it
    if [[ -n "${SSH_AUTH_SOCK:-}" ]]; then
        tmux set-environment -g SSH_AUTH_SOCK "$SSH_AUTH_SOCK" 2>/dev/null || true
    fi
}

# --- Main ---

main() {
    local mode="pool"
    local pool_dir
    pool_dir="$(get_pool_dir)"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all|-a)  mode="all"; shift ;;
            --kill|-k) mode="kill"; shift ;;
            --help|-h)
                echo "Usage: tms [--all|-a] [--kill|-k] [--help|-h] [directory]"
                echo ""
                echo "  tms              Pick/create session for current directory"
                echo "  tms <dir>        Pick/create session for <dir>"
                echo "  tms --all        Show all sessions across all pools"
                echo "  tms --kill       Kill sessions interactively"
                exit 0
                ;;
            *)
                pool_dir="$(cd "$1" && pwd)"
                shift
                ;;
        esac
    done

    fixup_ssh_agent

    case "$mode" in
        pool) pick_session_for_pool "$pool_dir" ;;
        all)  pick_session_all ;;
        kill) kill_sessions ;;
    esac
}

main "$@"
