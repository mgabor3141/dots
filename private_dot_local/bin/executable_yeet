#!/usr/bin/env bash
# yeet - push the current change to a remote branch.
trap 'echo "Error on line $LINENO: $BASH_COMMAND" >&2' ERR
set -Eeuo pipefail
#
# Default: find the nearest ancestor bookmark between trunk and the target
#          commit, move it to the target, and push. Falls back to creating a
#          new bookmark if none exists.
# --new/-n: always create a new bookmark and branch (for stacked PRs).
# --noai:   skip AI-generated PR title/description.

# Parse flags.
new_flag=false
noai_flag=false
args=""
for arg in "$@"; do
    case "$arg" in
        -n|--new) new_flag=true ;;
        --noai) noai_flag=true ;;
        *) args="$args $arg" ;;
    esac
done

# Fetch and rebase before pushing.
jj git fetch
jj reheat

# Abort if there are conflicts after rebasing.
if [ "$(jj log -r 'trunk()..@ & conflicts()' --count --no-pager)" -gt 0 ]; then
    echo "conflicts detected after rebase — resolve them before pushing"
    exit 1
fi

# Target: current commit if not empty, parent if empty.
target='(@ ~ empty()) | parents(@ & empty())'

# Decide mode: if --new, or no ancestor bookmark exists, create new.
bookmark=""
if [ "$new_flag" = false ]; then
    bookmark=$(jj log -r "trunk()..($target) & bookmarks()" --no-graph \
        -T 'local_bookmarks.map(|b| b.name()).join("\n")' \
        --limit 1 2>/dev/null | head -1)
fi

if [ -n "$bookmark" ]; then
    # Move existing bookmark to target and push.
    jj bookmark move "$bookmark" --to "$target" 2>&1
    output=$(jj git push --bookmark "$bookmark" $args 2>&1)
    rc=$?
else
    # Create a new bookmark via the push-new alias.
    output=$(jj push-new $args 2>&1)
    rc=$?
fi

printf '%s\n' "$output"

# Auto-open "create PR" links (contain /pull/new/ or /compare/).
url=$(printf '%s\n' "$output" | grep -oE 'https?://[^ ]+' | head -1)
if [ -n "$url" ]; then
    case "$url" in
        */pull/new/*|*/compare/*)
            # Generate PR title + description with AI and copy to clipboard.
            if [ "$noai_flag" = false ] && command -v pi >/dev/null 2>&1; then
                descriptions=$(jj log -r "trunk()..($target)" --no-graph \
                    -T 'description ++ "\n---\n"' 2>/dev/null)
                diff_stat=$(jj diff -r "trunk()..($target)" --stat 2>/dev/null)

                prompt="You are writing a GitHub pull request title and description.

Below are the commit descriptions and a diff stat for this PR.

Commit descriptions:
$descriptions

Diff stat:
$diff_stat

Write a concise PR title (one line, no prefix like 'PR:') and a PR description in markdown.
The description should summarize what changed and why, based on the commit messages.
Keep it concise — no filler, no restating the title in the body.
Output the title on the first line, then a blank line, then the description."

                echo "Generating PR title and description..."
                if pr_text=$(pi -p --no-session --no-tools "$prompt" 2>/dev/null); then
                    if command -v pbcopy >/dev/null 2>&1; then
                        printf '%s' "$pr_text" | pbcopy
                    elif command -v wl-copy >/dev/null 2>&1; then
                        printf '%s' "$pr_text" | wl-copy
                    elif command -v xclip >/dev/null 2>&1; then
                        printf '%s' "$pr_text" | xclip -selection clipboard
                    fi
                    echo "PR title and description copied to clipboard."
                    echo ""
                    printf '%s\n' "$pr_text"
                else
                    echo "AI generation failed, opening PR without it."
                fi
            fi

            if command -v open >/dev/null 2>&1; then
                open "$url"
            elif command -v xdg-open >/dev/null 2>&1; then
                xdg-open "$url"
            fi
            ;;
    esac
fi

exit $rc
