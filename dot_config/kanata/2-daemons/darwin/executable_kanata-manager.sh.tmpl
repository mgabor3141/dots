#!/bin/sh
set -eu

KANATA="/opt/homebrew/bin/kanata"
CONFIG_DIR="{{ .chezmoi.destDir }}/.config/kanata/1-configs"
POLL_INTERVAL=3

YELLOW='\033[0;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
RESET='\033[0m'
config_color() {
    case "$1" in
        macbook-ansi.kbd) echo "$YELLOW" ;;
        razer.kbd) echo "$GREEN" ;;
        go60.kbd) echo "$CYAN" ;;
        *) echo "$RESET" ;;
    esac
}

log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"; }

# Map config filenames to the device name used in macos-dev-names-include.
# hidutil list is used to check if the device is connected.
device_name() {
    case "$1" in
        macbook-ansi.kbd) echo "Apple Internal Keyboard / Trackpad" ;;
        razer.kbd) echo "Razer BlackWidow Ultimate" ;;
        go60.kbd) echo "Go60" ;;
    esac
}

device_connected() {
    hidutil list --matching '{}' 2>/dev/null | grep -qF "$1"
}

# Track running kanata instances: cfg -> PID
# POSIX sh doesn't have associative arrays, so use files in a temp dir.
STATE_DIR=$(mktemp -d)
trap 'rm -rf "$STATE_DIR"' EXIT

pid_file()  { echo "$STATE_DIR/$1.pid"; }
is_running() {
    pf=$(pid_file "$1")
    [ -f "$pf" ] && kill -0 "$(cat "$pf")" 2>/dev/null
}

start_kanata() {
    cfg="$1"
    log "Starting $cfg"
    # Start kanata directly (no pipeline) so $! captures the real kanata PID.
    # Previous version piped through `while read` for colored prefixes, but $!
    # then pointed at the subshell — stop_kanata would kill the shell and orphan
    # the kanata process, which kept an exclusive grab on the keyboard device.
    "$KANATA" --cfg "${CONFIG_DIR}/${cfg}" \
        >"/tmp/io.github.jtroo.kanata.${cfg%.kbd}.log" 2>&1 &
    echo "$!" > "$(pid_file "$cfg")"
    log "Started $cfg (pid $!)"
}

stop_kanata() {
    cfg="$1"
    pf=$(pid_file "$cfg")
    [ -f "$pf" ] || return 0
    pid=$(cat "$pf")
    log "Stopping $cfg (pid $pid)"
    kill "$pid" 2>/dev/null || true
    # Wait briefly then force-kill if still alive, so the device grab is released.
    sleep 1
    kill -9 "$pid" 2>/dev/null || true
    rm -f "$pf"
}

# Return the epoch seconds of the last system wake (0 if never slept since boot).
last_wake_epoch() {
    sysctl -n kern.waketime | sed 's/.*sec = \([0-9]*\).*/\1/'
}

# --- Main ---
log "Starting kanata-manager"
pkill -x kanata 2>/dev/null || true
sleep 1  # let existing kanata processes release device grabs

CONFIGS="macbook-ansi.kbd razer.kbd go60.kbd"
LAST_SEEN_WAKE=$(last_wake_epoch)

while true; do
    # --- Sleep/wake detection ---
    # After wake, kanata loses the Karabiner DriverKit device grab and becomes
    # non-functional even though the process is still alive (known upstream issue:
    # https://github.com/jtroo/kanata/issues/1357). Kill all instances so the
    # poll loop below restarts them with a fresh device grab.
    current_wake=$(last_wake_epoch)
    if [ "$current_wake" != "$LAST_SEEN_WAKE" ]; then
        log "Wake from sleep detected (wake epoch: $current_wake) — restarting all kanata instances"
        for cfg in $CONFIGS; do
            stop_kanata "$cfg"
        done
        pkill -x kanata 2>/dev/null || true
        sleep 2  # give Karabiner DriverKit time to re-enumerate devices
        LAST_SEEN_WAKE=$current_wake
    fi

    # --- Device polling ---
    for cfg in $CONFIGS; do
        dev=$(device_name "$cfg")
        connected=$(device_connected "$dev" && echo 1 || echo 0)
        running=$(is_running "$cfg" && echo 1 || echo 0)

        if [ "$connected" = "1" ] && [ "$running" = "0" ]; then
            start_kanata "$cfg"
        elif [ "$connected" = "0" ] && [ "$running" = "1" ]; then
            stop_kanata "$cfg"
        fi
    done

    sleep "$POLL_INTERVAL"
done
