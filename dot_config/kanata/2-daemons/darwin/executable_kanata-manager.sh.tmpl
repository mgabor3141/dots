#!/bin/sh
set -eu

KANATA="/opt/homebrew/bin/kanata"
CONFIG_DIR="{{ .chezmoi.destDir }}/.config/kanata/1-configs"
# Use /Library/Logs for persistence across reboots (manager runs as root).
# /tmp is cleared on reboot, which destroyed evidence of past incidents.
LOG_DIR="/Library/Logs/kanata"
POLL_INTERVAL=3
# How many seconds a device must be absent before we stop its kanata instance.
# Prevents BLE keyboards flapping from causing constant restarts, which
# destabilize other kanata instances (each restart triggers Karabiner DriverKit
# reconnection callbacks on ALL running instances).
DISCONNECT_GRACE=15
# Max log file size in bytes before rotation (~500KB)
LOG_MAX_SIZE=512000
# Wall-clock jump threshold for sleep detection (seconds).
# If the gap between polls exceeds this, the system likely slept.
SLEEP_THRESHOLD=30

log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"; }

# Map config filenames to the device name used in macos-dev-names-include.
# hidutil list is used to check if the device is connected.
device_name() {
    case "$1" in
        macbook-ansi.kbd) echo "Apple Internal Keyboard / Trackpad" ;;
        razer.kbd) echo "Razer BlackWidow Ultimate" ;;
        go60.kbd) echo "Go60" ;;
    esac
}

device_connected() {
    hidutil list --matching '{}' 2>/dev/null | grep -qF "$1"
}

log_file() { echo "${LOG_DIR}/io.github.jtroo.kanata.${1%.kbd}.log"; }

# Rotate a log file if it exceeds LOG_MAX_SIZE.
# Keeps one .old backup so we always have some history.
rotate_log() {
    lf=$(log_file "$1")
    if [ -f "$lf" ]; then
        sz=$(stat -f%z "$lf" 2>/dev/null || echo 0)
        if [ "$sz" -gt "$LOG_MAX_SIZE" ]; then
            mv -f "$lf" "${lf}.old"
            log "Rotated $lf (was ${sz} bytes)"
        fi
    fi
}

# Track running kanata instances: cfg -> PID
# POSIX sh doesn't have associative arrays, so use files in a temp dir.
STATE_DIR=$(mktemp -d)
trap 'rm -rf "$STATE_DIR"' EXIT

pid_file()  { echo "$STATE_DIR/$1.pid"; }
gone_file() { echo "$STATE_DIR/$1.gone"; }

is_running() {
    pf=$(pid_file "$1")
    [ -f "$pf" ] && kill -0 "$(cat "$pf")" 2>/dev/null
}

start_kanata() {
    cfg="$1"
    rotate_log "$cfg"
    log "Starting $cfg"
    # Append (>>) so we keep history across restarts for debugging.
    # Start kanata directly — do NOT pipe through a subshell, because $! would
    # capture the subshell PID instead of kanata's, and stop_kanata would then
    # orphan the real kanata process (which keeps an exclusive keyboard grab).
    "$KANATA" --cfg "${CONFIG_DIR}/${cfg}" --nodelay \
        >>"$(log_file "$cfg")" 2>&1 &
    echo "$!" > "$(pid_file "$cfg")"
    # Clear disconnect timer
    rm -f "$(gone_file "$cfg")"
    log "Started $cfg (pid $!)"
}

stop_kanata() {
    cfg="$1"
    pf=$(pid_file "$cfg")
    [ -f "$pf" ] || return 0
    pid=$(cat "$pf")
    log "Stopping $cfg (pid $pid)"
    kill "$pid" 2>/dev/null || true
    # Wait briefly for clean exit, then force-kill to prevent orphaned grabs
    sleep 1
    kill -9 "$pid" 2>/dev/null || true
    rm -f "$pf"
    rm -f "$(gone_file "$cfg")"
}

# Kill and restart all running kanata instances.
# Used after sleep/wake to ensure a clean DriverKit connection.
restart_all() {
    reason="$1"
    log "Restarting all kanata instances: $reason"
    for cfg in $CONFIGS; do
        if is_running "$cfg"; then
            stop_kanata "$cfg"
        fi
    done
    # Brief pause to let the Karabiner DriverKit daemon settle after wake
    sleep 2
    for cfg in $CONFIGS; do
        dev=$(device_name "$cfg")
        if device_connected "$dev"; then
            start_kanata "$cfg"
        fi
    done
}

# --- Main ---
mkdir -p "$LOG_DIR"
log "Starting kanata-manager"
pkill -x kanata 2>/dev/null || true

CONFIGS="macbook-ansi.kbd razer.kbd go60.kbd"
last_poll=$(date +%s)

while true; do
    now=$(date +%s)
    elapsed=$((now - last_poll))
    last_poll=$now

    # --- Sleep/wake detection ---
    # During sleep, wall-clock time advances but the process is frozen.
    # A large gap between polls means the system slept. After wake, the
    # Karabiner DriverKit connection is often broken (kanata holds the
    # keyboard grab but can't output keystrokes), so we force-restart.
    if [ "$elapsed" -gt "$SLEEP_THRESHOLD" ]; then
        log "Wake detected (${elapsed}s gap, threshold ${SLEEP_THRESHOLD}s)"
        restart_all "post-sleep recovery"
        continue
    fi

    for cfg in $CONFIGS; do
        dev=$(device_name "$cfg")
        connected=$(device_connected "$dev" && echo 1 || echo 0)
        running=$(is_running "$cfg" && echo 1 || echo 0)

        if [ "$connected" = "1" ] && [ "$running" = "0" ]; then
            # Device present but kanata not running — start it.
            # Clear any disconnect timer since the device is back.
            rm -f "$(gone_file "$cfg")"
            start_kanata "$cfg"
        elif [ "$connected" = "0" ] && [ "$running" = "1" ]; then
            # Device gone but kanata still running — apply grace period.
            # This debounces BLE keyboards that briefly disappear.
            gf=$(gone_file "$cfg")
            if [ ! -f "$gf" ]; then
                # First time we noticed the device is gone — record timestamp
                date +%s > "$gf"
            else
                gone_since=$(cat "$gf")
                now=$(date +%s)
                gap=$((now - gone_since))
                if [ "$gap" -ge "$DISCONNECT_GRACE" ]; then
                    log "$cfg device absent for ${gap}s, stopping"
                    stop_kanata "$cfg"
                fi
            fi
        elif [ "$connected" = "1" ] && [ "$running" = "1" ]; then
            # Both connected and running — clear any stale disconnect timer
            rm -f "$(gone_file "$cfg")"
        fi
    done

    sleep "$POLL_INTERVAL"
done
